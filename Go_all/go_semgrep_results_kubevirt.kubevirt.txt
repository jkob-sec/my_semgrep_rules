
Findings:

  /home/rtz/github_vuln_research/my_semgrep_rules/Go_all/repos_dir/kubevirt.kubevirt/cmd/example-cloudinit-hook-sidecar/cloudinit.go 
     home.rtz.github_vuln_research.my_semgrep_rules.go_semgrep_rules.grpc-server-insecure-connection
        Found an insecure gRPC server without 'grpc.Creds()' or options with credentials. This
        allows for a connection without encryption to this server. A malicious attacker could tamper
        with the gRPC message, which could compromise the machine. Include credentials derived from
        an SSL certificate in order to create a secure gRPC connection. You can create credentials
        using 'credentials.NewServerTLSFromFile("cert.pem", "cert.key")'.

        114┆ server := grpc.NewServer([]grpc.ServerOption{}...)


  /home/rtz/github_vuln_research/my_semgrep_rules/Go_all/repos_dir/kubevirt.kubevirt/cmd/example-disk-mutation-hook-sidecar/diskimage.go 
     home.rtz.github_vuln_research.my_semgrep_rules.go_semgrep_rules.grpc-server-insecure-connection
        Found an insecure gRPC server without 'grpc.Creds()' or options with credentials. This
        allows for a connection without encryption to this server. A malicious attacker could tamper
        with the gRPC message, which could compromise the machine. Include credentials derived from
        an SSL certificate in order to create a secure gRPC connection. You can create credentials
        using 'credentials.NewServerTLSFromFile("cert.pem", "cert.key")'.

        144┆ server := grpc.NewServer([]grpc.ServerOption{}...)


  /home/rtz/github_vuln_research/my_semgrep_rules/Go_all/repos_dir/kubevirt.kubevirt/cmd/example-guest-agent/main.go 
     home.rtz.github_vuln_research.my_semgrep_rules.go_semgrep_rules.grpc-client-insecure-connection
        Found an insecure gRPC connection using 'grpc.WithInsecure()'. This creates a connection
        without encryption to a gRPC server. A malicious attacker could tamper with the gRPC
        message, which could compromise the machine. Instead, establish a secure connection with an
        SSL certificate using the 'grpc.WithTransportCredentials()' function. You can create a
        create credentials using a 'tls.Config{}' struct with 'credentials.NewTLS()'. The final fix
        looks like this: 'grpc.WithTransportCredentials(credentials.NewTLS(<config>))'.

         ▶▶┆ Autofix ▶ s/(.*)WithInsecure\(.*?\)/\1WithTransportCredentials(credentials.NewTLS(<your_tls_config_here>))/g
        144┆ conn, err := grpc.Dial("something", dialOpt, grpc.WithInsecure())


  /home/rtz/github_vuln_research/my_semgrep_rules/Go_all/repos_dir/kubevirt.kubevirt/cmd/example-hook-sidecar/smbios.go 
     home.rtz.github_vuln_research.my_semgrep_rules.go_semgrep_rules.grpc-server-insecure-connection
        Found an insecure gRPC server without 'grpc.Creds()' or options with credentials. This
        allows for a connection without encryption to this server. A malicious attacker could tamper
        with the gRPC message, which could compromise the machine. Include credentials derived from
        an SSL certificate in order to create a secure gRPC connection. You can create credentials
        using 'credentials.NewServerTLSFromFile("cert.pem", "cert.key")'.

        164┆ server := grpc.NewServer([]grpc.ServerOption{}...)


  /home/rtz/github_vuln_research/my_semgrep_rules/Go_all/repos_dir/kubevirt.kubevirt/cmd/virt-chroot/main.go 
     home.rtz.github_vuln_research.my_semgrep_rules.go_semgrep_rules.dangerous-syscall-exec
        Detected non-static command inside Exec. Audit the input to 'syscall.Exec'. If unverified
        user data can reach this call site, this is a code injection vulnerability. A malicious
        actor can inject a malicious script to execute arbitrary code.

        125┆ err := syscall.Exec(args[0], args, os.Environ())


  /home/rtz/github_vuln_research/my_semgrep_rules/Go_all/repos_dir/kubevirt.kubevirt/pkg/network/driver/ethtool.go 
     home.rtz.github_vuln_research.my_semgrep_rules.go_semgrep_rules.use-of-unsafe-block
        Using the unsafe package in Go gives you low-level memory management and many of the
        strengths of the C language, but also steps around the type safety of Go and can lead to
        buffer overflows and possible arbitrary code execution by an attacker. Only use this package
        if you absolutely know what you're doing.

         54┆ request := IFReqData{Data: uintptr(unsafe.Pointer(&value))} // #nosec Used for a RawSyscall
          ⋮┆----------------------------------------
         57┆ if err := ioctlEthtool(socket, uintptr(unsafe.Pointer(&request))); err != nil { // #nosec Used for a RawSyscall
          ⋮┆----------------------------------------
         65┆ return ioctlEthtool(socket, uintptr(unsafe.Pointer(&request))) // #nosec Used for a RawSyscall


  /home/rtz/github_vuln_research/my_semgrep_rules/Go_all/repos_dir/kubevirt.kubevirt/pkg/virt-handler/device-manager/common.go 
     home.rtz.github_vuln_research.my_semgrep_rules.go_semgrep_rules.grpc-client-insecure-connection
        Found an insecure gRPC connection using 'grpc.WithInsecure()'. This creates a connection
        without encryption to a gRPC server. A malicious attacker could tamper with the gRPC
        message, which could compromise the machine. Instead, establish a secure connection with an
        SSL certificate using the 'grpc.WithTransportCredentials()' function. You can create a
        create credentials using a 'tls.Config{}' struct with 'credentials.NewTLS()'. The final fix
        looks like this: 'grpc.WithTransportCredentials(credentials.NewTLS(<config>))'.

         ▶▶┆ Autofix ▶ s/(.*)WithInsecure\(.*?\)/\1WithTransportCredentials(credentials.NewTLS(<your_tls_config_here>))/g
        216┆ c, err := grpc.Dial(socketPath,
        217┆ 	grpc.WithInsecure(),
        218┆ 	grpc.WithBlock(),
        219┆ 	grpc.WithTimeout(timeout),
        220┆ 	grpc.WithDialer(func(addr string, timeout time.Duration) (net.Conn, error) {
        221┆ 		return net.DialTimeout("unix", addr, timeout)
        222┆ 	}),
        223┆ )


  /home/rtz/github_vuln_research/my_semgrep_rules/Go_all/repos_dir/kubevirt.kubevirt/pkg/virt-handler/device-manager/generic_device.go 
     home.rtz.github_vuln_research.my_semgrep_rules.go_semgrep_rules.grpc-server-insecure-connection
        Found an insecure gRPC server without 'grpc.Creds()' or options with credentials. This
        allows for a connection without encryption to this server. A malicious attacker could tamper
        with the gRPC message, which could compromise the machine. Include credentials derived from
        an SSL certificate in order to create a secure gRPC connection. You can create credentials
        using 'credentials.NewServerTLSFromFile("cert.pem", "cert.key")'.

        135┆ dpi.server = grpc.NewServer([]grpc.ServerOption{}...)


  /home/rtz/github_vuln_research/my_semgrep_rules/Go_all/repos_dir/kubevirt.kubevirt/pkg/virt-handler/device-manager/mediated_device.go 
     home.rtz.github_vuln_research.my_semgrep_rules.go_semgrep_rules.grpc-server-insecure-connection
        Found an insecure gRPC server without 'grpc.Creds()' or options with credentials. This
        allows for a connection without encryption to this server. A malicious attacker could tamper
        with the gRPC message, which could compromise the machine. Include credentials derived from
        an SSL certificate in order to create a secure gRPC connection. You can create credentials
        using 'credentials.NewServerTLSFromFile("cert.pem", "cert.key")'.

        132┆ dpi.server = grpc.NewServer([]grpc.ServerOption{}...)


  /home/rtz/github_vuln_research/my_semgrep_rules/Go_all/repos_dir/kubevirt.kubevirt/pkg/virt-handler/device-manager/pci_device.go 
     home.rtz.github_vuln_research.my_semgrep_rules.go_semgrep_rules.grpc-server-insecure-connection
        Found an insecure gRPC server without 'grpc.Creds()' or options with credentials. This
        allows for a connection without encryption to this server. A malicious attacker could tamper
        with the gRPC message, which could compromise the machine. Include credentials derived from
        an SSL certificate in order to create a secure gRPC connection. You can create credentials
        using 'credentials.NewServerTLSFromFile("cert.pem", "cert.key")'.

        132┆ dpi.server = grpc.NewServer([]grpc.ServerOption{}...)


  /home/rtz/github_vuln_research/my_semgrep_rules/Go_all/repos_dir/kubevirt.kubevirt/pkg/virt-handler/isolation/detector.go 
     home.rtz.github_vuln_research.my_semgrep_rules.go_semgrep_rules.use-of-unsafe-block
        Using the unsafe package in Go gives you low-level memory management and many of the
        strengths of the C language, but also steps around the type safety of Go and can lead to
        buffer overflows and possible arbitrary code execution by an attacker. Only use this package
        if you absolutely know what you're doing.

        214┆ uintptr(unsafe.Pointer(&rlimit)), // #nosec used in unix RawSyscall6


  /home/rtz/github_vuln_research/my_semgrep_rules/Go_all/repos_dir/kubevirt.kubevirt/pkg/virt-handler/node-labeller/kvm-caps-info-plugin_amd64.go 
     home.rtz.github_vuln_research.my_semgrep_rules.go_semgrep_rules.use-of-unsafe-block
        Using the unsafe package in Go gives you low-level memory management and many of the
        strengths of the C language, but also steps around the type safety of Go and can lead to
        buffer overflows and possible arbitrary code execution by an attacker. Only use this package
        if you absolutely know what you're doing.

        135┆ msrsListPtr := unsafe.Pointer(&buffer[0])
          ⋮┆----------------------------------------
        150┆ C.msr_list_copy_nmsrs(unsafe.Pointer(&buffer[0]), unsafe.Pointer(&newBuffer[0]))
          ⋮┆----------------------------------------
        150┆ C.msr_list_copy_nmsrs(unsafe.Pointer(&buffer[0]), unsafe.Pointer(&newBuffer[0]))
          ⋮┆----------------------------------------
        152┆ msrsListPtr = unsafe.Pointer(&newBuffer[0])


  /home/rtz/github_vuln_research/my_semgrep_rules/Go_all/repos_dir/kubevirt.kubevirt/pkg/virt-handler/notify-server/server.go 
     home.rtz.github_vuln_research.my_semgrep_rules.go_semgrep_rules.grpc-server-insecure-connection
        Found an insecure gRPC server without 'grpc.Creds()' or options with credentials. This
        allows for a connection without encryption to this server. A malicious attacker could tamper
        with the gRPC message, which could compromise the machine. Include credentials derived from
        an SSL certificate in order to create a secure gRPC connection. You can create credentials
        using 'credentials.NewServerTLSFromFile("cert.pem", "cert.key")'.

        126┆ grpcServer := grpc.NewServer([]grpc.ServerOption{}...)


  /home/rtz/github_vuln_research/my_semgrep_rules/Go_all/repos_dir/kubevirt.kubevirt/pkg/virt-handler/selinux/labels.go 
     home.rtz.github_vuln_research.my_semgrep_rules.go_semgrep_rules.dangerous-exec-command
        Detected non-static command inside Command. Audit the input to 'exec.Command'. If unverified
        user data can reach this call site, this is a code injection vulnerability. A malicious
        actor can inject a malicious script to execute arbitrary code.

         30┆ return exec.Command(binary, args...).CombinedOutput()


  /home/rtz/github_vuln_research/my_semgrep_rules/Go_all/repos_dir/kubevirt.kubevirt/pkg/virt-handler/setsched.go 
     home.rtz.github_vuln_research.my_semgrep_rules.go_semgrep_rules.use-of-unsafe-block
        Using the unsafe package in Go gives you low-level memory management and many of the
        strengths of the C language, but also steps around the type safety of Go and can lead to
        buffer overflows and possible arbitrary code execution by an attacker. Only use this package
        if you absolutely know what you're doing.

         34┆ _, _, e1 := unix.Syscall(unix.SYS_SCHED_SETSCHEDULER, uintptr(pid), uintptr(policy), uintptr(unsafe.Pointer(&param)))


  /home/rtz/github_vuln_research/my_semgrep_rules/Go_all/repos_dir/kubevirt.kubevirt/pkg/virt-handler/vsock/server.go 
     home.rtz.github_vuln_research.my_semgrep_rules.go_semgrep_rules.grpc-server-insecure-connection
        Found an insecure gRPC server without 'grpc.Creds()' or options with credentials. This
        allows for a connection without encryption to this server. A malicious attacker could tamper
        with the gRPC message, which could compromise the machine. Include credentials derived from
        an SSL certificate in order to create a secure gRPC connection. You can create credentials
        using 'credentials.NewServerTLSFromFile("cert.pem", "cert.key")'.

         48┆ h.server = grpc.NewServer()


  /home/rtz/github_vuln_research/my_semgrep_rules/Go_all/repos_dir/kubevirt.kubevirt/pkg/virt-launcher/virtwrap/cmd-server/server.go 
     home.rtz.github_vuln_research.my_semgrep_rules.go_semgrep_rules.grpc-server-insecure-connection
        Found an insecure gRPC server without 'grpc.Creds()' or options with credentials. This
        allows for a connection without encryption to this server. A malicious attacker could tamper
        with the gRPC message, which could compromise the machine. Include credentials derived from
        an SSL certificate in order to create a secure gRPC connection. You can create credentials
        using 'credentials.NewServerTLSFromFile("cert.pem", "cert.key")'.

        558┆ grpcServer := grpc.NewServer([]grpc.ServerOption{}...)


  /home/rtz/github_vuln_research/my_semgrep_rules/Go_all/repos_dir/kubevirt.kubevirt/pkg/virt-operator/resource/generate/install/strategy.go 
     home.rtz.github_vuln_research.my_semgrep_rules.go_semgrep_rules.potential-dos-via-decompression-bomb
        Detected a possible denial-of-service via a zip bomb attack. By limiting the max bytes read,
        you can mitigate this attack. `io.CopyN()` can specify a size. Refer to https://bomb.codes/
        to learn more about this attack and other ways to mitigate it.

         ▶▶┆ Autofix ▶ s/(.*)(Copy|CopyBuffer)\((.*?),(.*?)(\)|,.*\))/\1CopyN(\3, \4, 1024*1024*256)/g
        239┆ if _, err := io.Copy(&decodedStrategy, zr); err != nil {


  /home/rtz/github_vuln_research/my_semgrep_rules/Go_all/repos_dir/kubevirt.kubevirt/pkg/virtctl/ssh/wrapped.go 
     home.rtz.github_vuln_research.my_semgrep_rules.go_semgrep_rules.dangerous-exec-command
        Detected non-static command inside Command. Audit the input to 'exec.Command'. If unverified
        user data can reach this call site, this is a code injection vulnerability. A malicious
        actor can inject a malicious script to execute arbitrary code.

         30┆ cmd := exec.Command(options.LocalClientName, args...)
