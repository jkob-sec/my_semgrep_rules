
Findings:

  /home/rtz/github_vuln_research/my_semgrep_rules/custom_repos/repos_dir/kubevela.kubevela/e2e/cli.go 
     home.rtz.github_vuln_research.my_semgrep_rules.go_semgrep_rules.dangerous-exec-command
        Detected non-static command inside Command. Audit the input to 'exec.Command'. If unverified
        user data can reach this call site, this is a code injection vulnerability. A malicious
        actor can inject a malicious script to execute arbitrary code.

         78┆ command := exec.Command(commandName, c[1:]...)
          ⋮┆----------------------------------------
         87┆ command := exec.Command(commandName, c[1:]...)
          ⋮┆----------------------------------------
        115┆ command := exec.Command(commandName, c[1:]...)


  /home/rtz/github_vuln_research/my_semgrep_rules/custom_repos/repos_dir/kubevela.kubevela/pkg/utils/parallel/parallel.go 
     home.rtz.github_vuln_research.my_semgrep_rules.go_semgrep_rules.reflect-makefunc
        'reflect.MakeFunc' detected. This will sidestep protections that are normally afforded by
        Go's type system. Audit this call and be sure that user input cannot be used to affect the
        code generated by MakeFunc; otherwise, you will have a serious security vulnerability.

         82┆ _handler := reflect.MakeFunc(reflect.TypeOf(func(ParInput) ParOutput { return nil }), func(args []reflect.Value) (results []reflect.Value) {
         83┆ 	in := make([]reflect.Value, nParams)
         84┆ 	_inputVal := args[0].Elem()
         85┆ 	if nParams > 1 {
         86┆ 		for i := 0; i < nParams; i++ {
         87┆ 			in[i] = _inputVal.Index(i).Elem()
         88┆ 		}
         89┆ 	} else if nParams == 1 {
         90┆ 		in[0] = _inputVal
         91┆ 	}
           [hid 23 additional lines, adjust with --max-lines-per-finding] 
