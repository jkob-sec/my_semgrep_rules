
Findings:

  /home/rtz/github_vuln_research/my_semgrep_rules/Python_all/bram2w.baserow/backend/src/baserow/contrib/database/db/schema.py 
     home.rtz.github_vuln_research.my_semgrep_rules.python_semgrep_rules.sqlalchemy-execute-raw-query
        Avoiding SQL string concatenation: untrusted input concatenated with raw SQL query can
        result in SQL Injection. In order to execute raw query safely, prepared statement should be
        used. SQLAlchemy provides TextualSQL to easily used prepared statement with named
        parameters. For complex SQL composition, use SQL Expression Language or Schema Definition
        Language. In most cases, SQLAlchemy ORM will be a better option.

         70┆ self.execute(
         71┆     sql_create_try_cast
         72┆     % {
         73┆         "column": quoted_column_name,
         74┆         "type": new_type,
         75┆         "alter_column_prepare_old_value": alter_column_prepare_old_value,
         76┆         "alter_column_prepare_new_value": alter_column_prepare_new_value,
         77┆     },
         78┆     variables,
         79┆ )
          ⋮┆----------------------------------------
        318┆ self.execute(
        319┆     self.sql_delete_table
        320┆     % {
        321┆         "table": self.quote_name(model._meta.db_table),
        322┆     }
        323┆ )


  /home/rtz/github_vuln_research/my_semgrep_rules/Python_all/bram2w.baserow/backend/src/baserow/contrib/database/fields/backup_handler.py 
     home.rtz.github_vuln_research.my_semgrep_rules.python_semgrep_rules.sqlalchemy-execute-raw-query
        Avoiding SQL string concatenation: untrusted input concatenated with raw SQL query can
        result in SQL Injection. In order to execute raw query safely, prepared statement should be
        used. SQLAlchemy provides TextualSQL to easily used prepared statement with named
        parameters. For complex SQL composition, use SQL Expression Language or Schema Definition
        Language. In most cases, SQLAlchemy ORM will be a better option.

        218┆ cursor.execute(
        219┆     sql.SQL("TRUNCATE TABLE {target_table}").format(
        220┆         target_table=sql.Identifier(target_table),
        221┆     )
        222┆ )
          ⋮┆----------------------------------------
        227┆ cursor.execute(
        228┆     sql.SQL("DROP TABLE {backup_table}").format(
        229┆         backup_table=sql.Identifier(backup_name),
        230┆     )
        231┆ )
          ⋮┆----------------------------------------
        243┆ cursor.execute(
        244┆     sql.SQL(
        245┆         """
        246┆     INSERT INTO {target_table} (id, {m2m_column}, {m2m_reverse_target_column})
        247┆     SELECT id, {m2m_column}, {m2m_reverse_column} FROM {source_table}
        248┆     """
        249┆     ).format(
        250┆         source_table=sql.Identifier(source_table),
        251┆         target_table=sql.Identifier(target_table),
        252┆         m2m_column=sql.Identifier(m2m_model_field.m2m_column_name()),
           [hid 8 additional lines, adjust with --max-lines-per-finding] 
        286┆ cursor.execute(
        287┆     sql.SQL(
        288┆         "UPDATE {table_name} SET {target_column} = {source_column} "
        289┆         "WHERE {source_column} IS NOT NULL"
        290┆     ).format(
        291┆         table_name=sql.Identifier(table_name),
        292┆         target_column=sql.Identifier(target_column),
        293┆         source_column=sql.Identifier(source_column),
        294┆     )
        295┆ )
          ⋮┆----------------------------------------
        300┆ cursor.execute(
        301┆     sql.SQL("ALTER TABLE {table_name} DROP COLUMN {column_to_drop}").format(
        302┆         table_name=sql.Identifier(table_name),
        303┆         column_to_drop=sql.Identifier(column_to_drop),
        304┆     )
        305┆ )


  /home/rtz/github_vuln_research/my_semgrep_rules/Python_all/bram2w.baserow/backend/src/baserow/contrib/database/fields/field_converters.py 
     home.rtz.github_vuln_research.my_semgrep_rules.python_semgrep_rules.sqlalchemy-execute-raw-query
        Avoiding SQL string concatenation: untrusted input concatenated with raw SQL query can
        result in SQL Injection. In order to execute raw query safely, prepared statement should be
        used. SQLAlchemy provides TextualSQL to easily used prepared statement with named
        parameters. For complex SQL composition, use SQL Expression Language or Schema Definition
        Language. In most cases, SQLAlchemy ORM will be a better option.

        167┆ cursor.execute(
        168┆     sql.SQL("insert into {table} ({column_1}, {column_2}) {vals}").format(
        169┆         table=sql.Identifier(self.through_table_name),
        170┆         column_1=sql.Identifier(self.through_table_column_name),
        171┆         column_2=sql.Identifier(self.through_select_option_column_name),
        172┆         vals=subselect,
        173┆     ),
        174┆ )
          ⋮┆----------------------------------------
        191┆ update_stmt = sql.SQL(
        192┆     """
        193┆     update {table} as u
        194┆         set {db_column} = vals.new_value
        195┆     from ({values_list}) as vals(id, new_value)
        196┆     where vals.id = u.id
        197┆     """
        198┆ ).format(
        199┆     table=sql.Identifier(table),
        200┆     db_column=sql.Identifier(db_column),
           [hid 4 additional lines, adjust with --max-lines-per-finding] 


  /home/rtz/github_vuln_research/my_semgrep_rules/Python_all/bram2w.baserow/backend/src/baserow/contrib/database/fields/handler.py 
     home.rtz.github_vuln_research.my_semgrep_rules.python_semgrep_rules.sqlalchemy-execute-raw-query
        Avoiding SQL string concatenation: untrusted input concatenated with raw SQL query can
        result in SQL Injection. In order to execute raw query safely, prepared statement should be
        used. SQLAlchemy provides TextualSQL to easily used prepared statement with named
        parameters. For complex SQL composition, use SQL Expression Language or Schema Definition
        Language. In most cases, SQLAlchemy ORM will be a better option.

       1046┆ cursor.execute(
       1047┆     sql_create_try_cast
       1048┆     % {
       1049┆         "alter_column_prepare_old_value": alter_column_prepare_old_value
       1050┆         or "",
       1051┆         "alter_column_prepare_new_value": "",
       1052┆         "type": "text",
       1053┆     },
       1054┆     variables,
       1055┆ )
          ⋮┆----------------------------------------
       1099┆ query = sql.SQL(
       1100┆     """
       1101┆     select col
       1102┆     from ({table_select}) as tmp_table
       1103┆     where col != '' and col is NOT NULL
       1104┆     group by col
       1105┆     order by count(col) DESC
       1106┆     limit {limit}
       1107┆     """
       1108┆ ).format(
           [hid 7 additional lines, adjust with --max-lines-per-finding] 


  /home/rtz/github_vuln_research/my_semgrep_rules/Python_all/bram2w.baserow/backend/src/baserow/contrib/database/migrations/0028_fix_negative_date.py 
     home.rtz.github_vuln_research.my_semgrep_rules.python_semgrep_rules.sqlalchemy-execute-raw-query
        Avoiding SQL string concatenation: untrusted input concatenated with raw SQL query can
        result in SQL Injection. In order to execute raw query safely, prepared statement should be
        used. SQLAlchemy provides TextualSQL to easily used prepared statement with named
        parameters. For complex SQL composition, use SQL Expression Language or Schema Definition
        Language. In most cases, SQLAlchemy ORM will be a better option.

         17┆ tables_schema_editor.execute(
         18┆     f"""
         19┆         UPDATE {table_name} SET {field_name} = '0001-01-01'::date
         20┆         WHERE {field_name} < '0001-01-01'::date
         21┆     """
         22┆ )


  /home/rtz/github_vuln_research/my_semgrep_rules/Python_all/bram2w.baserow/backend/src/baserow/contrib/database/migrations/0031_fix_url_field_max_length.py 
     home.rtz.github_vuln_research.my_semgrep_rules.python_semgrep_rules.sqlalchemy-execute-raw-query
        Avoiding SQL string concatenation: untrusted input concatenated with raw SQL query can
        result in SQL Injection. In order to execute raw query safely, prepared statement should be
        used. SQLAlchemy provides TextualSQL to easily used prepared statement with named
        parameters. For complex SQL composition, use SQL Expression Language or Schema Definition
        Language. In most cases, SQLAlchemy ORM will be a better option.

         17┆ tables_schema_editor.execute(
         18┆     f"""ALTER TABLE {table_name} ALTER COLUMN {field_name} TYPE text"""
         19┆ )


  /home/rtz/github_vuln_research/my_semgrep_rules/Python_all/bram2w.baserow/backend/src/baserow/contrib/database/migrations/0032_trash.py 
     home.rtz.github_vuln_research.my_semgrep_rules.python_semgrep_rules.sqlalchemy-execute-raw-query
        Avoiding SQL string concatenation: untrusted input concatenated with raw SQL query can
        result in SQL Injection. In order to execute raw query safely, prepared statement should be
        used. SQLAlchemy provides TextualSQL to easily used prepared statement with named
        parameters. For complex SQL composition, use SQL Expression Language or Schema Definition
        Language. In most cases, SQLAlchemy ORM will be a better option.

         40┆ tables_schema_editor.execute(
         41┆     f"ALTER TABLE {table_name} DROP COLUMN IF EXISTS trashed"
         42┆ )


  /home/rtz/github_vuln_research/my_semgrep_rules/Python_all/bram2w.baserow/backend/src/baserow/contrib/database/migrations/0050_remove_multiselect_missing_options.py 
     home.rtz.github_vuln_research.my_semgrep_rules.python_semgrep_rules.sqlalchemy-execute-raw-query
        Avoiding SQL string concatenation: untrusted input concatenated with raw SQL query can
        result in SQL Injection. In order to execute raw query safely, prepared statement should be
        used. SQLAlchemy provides TextualSQL to easily used prepared statement with named
        parameters. For complex SQL composition, use SQL Expression Language or Schema Definition
        Language. In most cases, SQLAlchemy ORM will be a better option.

         22┆ cursor.execute(
         23┆     (
         24┆         "DELETE FROM %(table)s "  # nosec
         25┆         "WHERE %(select_column)s NOT IN "
         26┆         "(SELECT id FROM %(option_table)s)"
         27┆     )
         28┆     % {
         29┆         "select_column": (
         30┆             f"multipleselectfield{field.id}selectoption_id"
         31┆         ),
           [hid 4 additional lines, adjust with --max-lines-per-finding] 


  /home/rtz/github_vuln_research/my_semgrep_rules/Python_all/bram2w.baserow/backend/src/baserow/contrib/database/migrations/0052_table_order_and_id_index.py 
     home.rtz.github_vuln_research.my_semgrep_rules.python_semgrep_rules.sqlalchemy-execute-raw-query
        Avoiding SQL string concatenation: untrusted input concatenated with raw SQL query can
        result in SQL Injection. In order to execute raw query safely, prepared statement should be
        used. SQLAlchemy provides TextualSQL to easily used prepared statement with named
        parameters. For complex SQL composition, use SQL Expression Language or Schema Definition
        Language. In most cases, SQLAlchemy ORM will be a better option.

         94┆ schema_editor.execute((f'DROP INDEX CONCURRENTLY IF EXISTS "{index_name}"'))


  /home/rtz/github_vuln_research/my_semgrep_rules/Python_all/bram2w.baserow/backend/src/baserow/contrib/database/table/usage_types.py 
     home.rtz.github_vuln_research.my_semgrep_rules.python_semgrep_rules.sqlalchemy-execute-raw-query
        Avoiding SQL string concatenation: untrusted input concatenated with raw SQL query can
        result in SQL Injection. In order to execute raw query safely, prepared statement should be
        used. SQLAlchemy provides TextualSQL to easily used prepared statement with named
        parameters. For complex SQL composition, use SQL Expression Language or Schema Definition
        Language. In most cases, SQLAlchemy ORM will be a better option.

         43┆ cursor.execute(
         44┆     FILENAMES_PER_GROUP_PLPGSQL_FUNCTION.format(
         45┆         database_table_prefix=Table.USER_TABLE_DATABASE_NAME_PREFIX,
         46┆         filefields_query=str(
         47┆             FileField.objects.filter(
         48┆                 table__trashed=False,
         49┆                 table__database__trashed=False,
         50┆                 table__database__group=9999,
         51┆             )
         52┆             .only("id", "table_id")
           [hid 4 additional lines, adjust with --max-lines-per-finding] 


  /home/rtz/github_vuln_research/my_semgrep_rules/Python_all/bram2w.baserow/backend/src/baserow/contrib/database/tokens/handler.py 
     home.rtz.github_vuln_research.my_semgrep_rules.python_semgrep_rules.dangerous-globals-use
        Found non static data as an index to 'globals()'. This is extremely dangerous because it
        allows an attacker to execute arbitrary code on the system. Refactor your code not to use
        'globals()'.

        287┆ value = locals()[type_name]


  /home/rtz/github_vuln_research/my_semgrep_rules/Python_all/bram2w.baserow/backend/src/baserow/core/db.py 
     home.rtz.github_vuln_research.my_semgrep_rules.python_semgrep_rules.sqlalchemy-execute-raw-query
        Avoiding SQL string concatenation: untrusted input concatenated with raw SQL query can
        result in SQL Injection. In order to execute raw query safely, prepared statement should be
        used. SQLAlchemy provides TextualSQL to easily used prepared statement with named
        parameters. For complex SQL composition, use SQL Expression Language or Schema Definition
        Language. In most cases, SQLAlchemy ORM will be a better option.

         35┆ cursor.execute(
         36┆     "LOCK TABLE {db_table_name}".format(
         37┆         db_table_name=self.model._meta.db_table
         38┆     )
         39┆ )
          ⋮┆----------------------------------------
        184┆ cursor.execute("SET TRANSACTION ISOLATION LEVEL %s" % isolation_level)


  /home/rtz/github_vuln_research/my_semgrep_rules/Python_all/bram2w.baserow/backend/src/baserow/core/registries.py 
     home.rtz.github_vuln_research.my_semgrep_rules.python_semgrep_rules.use-defused-xmlrpc
        Detected use of xmlrpc. xmlrpc is not inherently safe from vulnerabilities. Use
        defusedxml.xmlrpc instead.

          5┆ from xmlrpc.client import Boolean


  /home/rtz/github_vuln_research/my_semgrep_rules/Python_all/bram2w.baserow/backend/src/baserow/test_utils/fixtures/view.py 
     home.rtz.github_vuln_research.my_semgrep_rules.python_semgrep_rules.use-none-for-password-default
        'password' is using the empty string as its default and is being used to set the password on
        'view'. If you meant to set an unusable password, set the default value to 'None' or call
        'set_unusable_password()'.

         ▶▶┆ Autofix ▶ None
        219┆ self, user=None, password=None, **kwargs
          ⋮┆----------------------------------------
         ▶▶┆ Autofix ▶ None
        237┆ self, user=None, password=None, **kwargs


  /home/rtz/github_vuln_research/my_semgrep_rules/Python_all/bram2w.baserow/enterprise/backend/src/baserow_enterprise/auth_provider/handler.py 
     home.rtz.github_vuln_research.my_semgrep_rules.python_semgrep_rules.sqlalchemy-execute-raw-query
        Avoiding SQL string concatenation: untrusted input concatenated with raw SQL query can
        result in SQL Injection. In order to execute raw query safely, prepared statement should be
        used. SQLAlchemy provides TextualSQL to easily used prepared statement with named
        parameters. For complex SQL composition, use SQL Expression Language or Schema Definition
        Language. In most cases, SQLAlchemy ORM will be a better option.

        180┆ cursor.execute(
        181┆     sql.SQL("SELECT last_value + 1 from {table_id_seq};").format(
        182┆         table_id_seq=sql.Identifier(
        183┆             f"{AuthProviderModel._meta.db_table}_id_seq"
        184┆         )
        185┆     )
        186┆ )


  /home/rtz/github_vuln_research/my_semgrep_rules/Python_all/bram2w.baserow/premium/backend/src/baserow_premium/admin/users/handler.py 
     home.rtz.github_vuln_research.my_semgrep_rules.python_semgrep_rules.use-none-for-password-default
        'password' is using the empty string as its default and is being used to set the password on
        'user'. If you meant to set an unusable password, set the default value to 'None' or call
        'set_unusable_password()'.

         ▶▶┆ Autofix ▶ None
         29┆ password: Optional[str] = None,


  /home/rtz/github_vuln_research/my_semgrep_rules/Python_all/bram2w.baserow/premium/backend/src/baserow_premium/export/utils.py 
     home.rtz.github_vuln_research.my_semgrep_rules.python_semgrep_rules.use-defused-xml
        The Python documentation recommends using `defusedxml` instead of `xml` because the native
        Python `xml` library is vulnerable to XML External Entity (XXE) attacks. These attacks can
        leak confidential data and "XML bombs" can cause denial of service.

          6┆ from xml.sax.saxutils import escape  # nosec
